###################################################################################################
# Map team name to team code
dt.team_code <- data.table(team = c('Atlanta Hawks','Boston Celtics','Brooklyn Nets','Charlotte Hornets','Chicago Bulls',
'Cleveland Cavaliers','Dallas Mavericks','Denver Nuggets','Detroit Pistons','Golden State Warriors',
'Houston Rockets','Indiana Pacers','Los Angeles Clippers','Los Angeles Lakers','Memphis Grizzlies',
'Miami Heat','Milwaukee Bucks','Minnesota Timberwolves','New Orleans Pelicans','New York Knicks',
'Oklahoma City Thunder','Orlando Magic','Philadelphia 76ers','Phoenix Suns','Portland Trail Blazers',
'Sacramento Kings','San Antonio Spurs','Toronto Raptors','Utah Jazz','Washington Wizards'),
team_code = c("ATL", "BRK", "BOS", "CHO", "CHI",
"CLE", "DAL", "DEN", "DET", "GSW",
"HOU", "IND", "LAC", "LAL", "MEM",
"MIA", "MIL", "MIN", "NOP", "NYK",
"OKC", "ORL", "PHI", "PHO", "POR",
"SAC", "SAS", "TOR", "UTA", "WAS"))
lastmon <- function(x) 7 * floor(as.numeric(x-1+4)/7) + as.Date(1-4, origin="1970-01-01")
start_date <- floor_date(Sys.Date())
# Get current standings
url <- "https://www.basketball-reference.com/leagues/NBA_2019.html"
eastern_conference_list <- url %>%
read_html() %>%
html_nodes(xpath='//*[@id="confs_standings_E"]') %>%
html_table()
eastern_conference_list <- eastern_conference_list[[1]]
eastern_conference_list <- eastern_conference_list[,c(1:3)]
colnames(eastern_conference_list) <- c("team", "wins", "losses")
western_conference_list <- url %>%
read_html() %>%
html_nodes(xpath='//*[@id="confs_standings_W"]') %>%
html_table()
western_conference_list <- western_conference_list[[1]]
western_conference_list <- western_conference_list[,c(1:3)]
colnames(western_conference_list) <- c("team", "wins", "losses")
dt.all_standings <- rbind(data.table(eastern_conference_list),
data.table(western_conference_list))
dt.all_standings[,total_games := wins+losses]
dt.all_standings[,wins := NULL]
dt.all_standings[,losses := NULL]
dt.all_standings[,team := unlist(strsplit(team, "\\("))[1], by = 1:nrow(dt.all_standings)]
dt.all_standings[,team := substr(team, 1, nchar(team) - 1)]
dt.player_links <- data.table(NBAPerGameAdvStatistics(season = 2019))
dt.player_links <- unique(dt.player_links[,list(player, link)])
players <- NBAPerGameStatistics(season = 2019)
dt.players <- data.table(players)
dt.players <- dt.players[,list(player,
team_code = tm,
position = pos,
game = g,
minutes_played = mp,
two_point = x2p,
two_point_attempt = x2pa,
three_point = x3p,
three_point_attempt = x3pa,
free_throw = ft,
free_throw_attempt = fta,
rebounds = trb,
assists = ast,
steals = stl,
blocks = blk,
turnovers = tov)]
dt.players[,avg_fantasy_points := two_point * 3 - two_point_attempt +
three_point * 4 - three_point_attempt +
free_throw * 2 - free_throw_attempt +
rebounds + assists + blocks * 3 + steals * 3 - turnovers]
dt.final_players <- dt.players[,list(player, position, minutes_played, game, team_code, avg_fantasy_points)]
# Keep most recent team for player that have been traded
dt.final_players[,id := 1:nrow(dt.final_players)]
dt.final_players <- dt.final_players[dt.final_players[, .I[id == max(id)], by=player]$V1]
dt.final_players[,id := NULL]
# funcGetInjuries <- function(vec_players){
#   dt.return.this <- rbindlist(lapply(vec_players, function(my_player){
#     print(my_player)
#     link <- paste0("https://www.basketball-reference.com",
#                    paste0(dt.player_links[player == my_player]$link))
#
#     injury_list <- link %>%
#       read_html() %>%
#       html_nodes(xpath='//*[@id="injury"]')
#
#
#     if (length(injury_list) > 0){
#       dt.return <- data.table(player = my_player,
#                               injured = TRUE)
#     } else{
#
#       dt.return <- data.table(player = my_player,
#                               injured = FALSE)
#     }
#     return (dt.return)
#
#   }))
#
#   return(dt.return.this)
# }
funcGetInjuries <- function(){
link <- "https://www.basketball-reference.com/friv/injuries.fcgi"
injury_list <- link %>%
read_html() %>%
html_table()
dt.return.this <- data.table(injury_list[[1]])
dt.return.this <- dt.return.this[,list(player = Player,
injured = TRUE)]
return (dt.return.this)
}
dt.injuries <- funcGetInjuries()
# Grab player game data for the week
getPlayerPerformance <- function(vec_players){
dt.return.this <- rbindlist(lapply(vec_players, function(my_player){
print(my_player)
link <- paste0("https://www.basketball-reference.com",
gsub(".html", glue("/gamelog/2019/"), paste0(dt.player_links[player == my_player]$link)))
season_games_list <- link %>%
read_html() %>%
html_nodes(xpath='//*[@id="pgl_basic"]') %>%
html_table(fill = TRUE)
season_games_list <- season_games_list[[1]]
dt.season_games_list <- data.table(season_games_list)
dt.season_games_list[,G := as.numeric(G)]
dt.season_games_list <- dt.season_games_list[!is.na(G)]
dt.season_games_list <- dt.season_games_list[,list(player = my_player,
game = G,
dt = as.Date(Date),
team = Tm,
opponent = Opp,
two_point = as.numeric(FG) - as.numeric(`3P`),
two_point_attempt = as.numeric(FGA) - as.numeric(`3PA`),
three_point = as.numeric(`3P`),
three_point_attempt = as.numeric(`3PA`),
free_throw = as.numeric(FT),
free_throw_attempt = as.numeric(FTA),
rebounds = as.numeric(TRB),
assists = as.numeric(AST),
steals = as.numeric(STL),
blocks = as.numeric(BLK),
turnovers = as.numeric(TOV),
points = as.numeric(PTS)
)]
dt.season_games_list[,fantasy_points := two_point * 3 - two_point_attempt +
three_point * 4 - three_point_attempt +
free_throw * 2 - free_throw_attempt +
rebounds + assists + blocks * 3 + steals * 3 - turnovers]
return (dt.season_games_list)
}))
return (dt.return.this)
}
# dt.final_players[,owner := "none"]
# dt.final_players[,status := "available"]
# dt.final_players[player %in% vec.my_players]$owner <- "me"
# dt.final_players[player %in% vec.alex]$owner <- "alex"
# dt.final_players[player %in% vec.kyle]$owner <- "kyle"
# dt.final_players[player %in% vec.edward]$owner <- "edward"
# dt.final_players[player %in% vec.daniel]$owner <- "daniel"
# dt.final_players[player %in% vec.liam]$owner <- "liam"
# dt.final_players[owner != "none",status := "unavailable"]
runApp('D:/Desktop/nba_fantasy/shiny')
dt.plot.this
dt.player_performance_with_owner
dt.player_performance
runApp('D:/Desktop/nba_fantasy/shiny')
runApp('D:/Desktop/nba_fantasy/shiny')
dt.plot.this
dt.player_performance
dt.plot.this
str(dt.plot.this)
plt <- ggplot(dt.plot.this, aes(x = dt, y = fantasy_points, color = owner, group = owner)) +
geom_line() + theme_bw(base_size = 15) + scale_color_brewer(palette = "set1")
plt <- ggplot(dt.plot.this, aes(x = dt, y = fantasy_points, color = owner, group = owner)) +
geom_line() + theme_bw(base_size = 15) + scale_color_brewer(palette = "Set1")
runApp('D:/Desktop/nba_fantasy/shiny')
dt.plot.this
dt.player_performance_with_owner
dt.player_performance
start_date
lastmon <- function(x) 7 * floor(as.numeric(x-1+4)/7) + as.Date(1-4, origin="1970-01-01")
start_date <- floor_date(Sys.Date())
start_date
floor_date
start_date <- lastmon(Sys.Date())
start_date
runApp('D:/Desktop/nba_fantasy/shiny')
dt.plot.this
dt.player_performance
dt.player_schedule
dt.return.this
dt.plot.this.predicted <- dt.return.this[,list(predicted_fantasy_points = sum(avg_fantasy_points),
bu = list(dt, owner))]
dt.plot.this.predicted
dt.plot.this.predicted <- dt.return.this[,list(predicted_fantasy_points = sum(avg_fantasy_points),
by = list(dt, owner))]
dt.plot.this.predicted
dt.return.this
dt.plot.this.predicted <- dt.return.this[,list(predicted_fantasy_points = sum(avg_fantasy_points)),
by = list(dt, owner)]
dt.plot.this.predicted
dt.plot.merged <- merge(dt.plot.this, dt.plot.this.predicted,
by = c("dt", "owner"), all.y = TRUE)
dt.plot.merged
dt.plot.this <- dt.player_performance_with_owner[,list(fantasy_points = sum(fantasy_points),
type = "actual"),
by = list(dt, owner)]
dt.plot.this
dt.plot.this.predicted <- dt.return.this[,list(fantasy_points = sum(avg_fantasy_points),
type = "predicted"),
by = list(dt, owner)]
dt.plot.merged <- rbind(dt.plot.this, dt.plot.this.predicted)
dt.plot.merged
runApp('D:/Desktop/nba_fantasy/shiny')
runApp('D:/Desktop/nba_fantasy/shiny')
dt.plot.merged
dt.player_performance_with_owner
dt.return.this
dt.player_schedule
dt.return.this
dt.return.this[dt == "2018-12-17"]
dt.return.this[dt == "2018-12-18"]
dt.return.this[dt == "2018-12-19"]
dt.plot.merged$dt <- as.Date(dt.plot.merged$dt)
dt.plot.merged
runApp('D:/Desktop/nba_fantasy/shiny')
runApp('D:/Desktop/nba_fantasy/shiny')
runApp('D:/Desktop/nba_fantasy/shiny')
# https://github.com/abresler/requestsR
# https://stmorse.github.io/journal/espn-fantasy-python.html
library(requestsR)
library(reticulate)
library(jsonlite)
install.packages("reticulate")
devtools::install_github("abresler/requestsR")
install.packages("purrr")
install.packages("purrr")
devtools::install_github("abresler/requestsR")
shiny::runApp('D:/Desktop/nba_fantasy/shiny')
runApp('D:/Desktop/nba_fantasy/shiny')
resp <- Get(url = 'http://fantasy.espn.com/basketball/team?leagueId=8490389&teamId=1')
resp
page <-
resp %>%
parse_response_html()
page
as.character(page)
chr.base_url <- glue("http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mBoxscore&view=mMatchupScore&view=mSchedule&view=mScoreboard&view=mSettings&view=mStatus&view=mTeam&view=mRoster&view=modular&view=mNav")
chr.base_url
dt.results <- data.table(fromJSON(txt=chr.base_url, simplifyDataFrame=T))
raw.result <- GET(url = url)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mMatchup&view=mMatchupScore&scoringPeriodId=64"
raw.result <- GET(url = url)
# https://github.com/abresler/requestsR
# https://stmorse.github.io/journal/espn-fantasy-python.html
# https://dusty-turner.netlify.com/post/mathlete-fantasy-football-analysis/
library(jsonlite)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mMatchup&view=mMatchupScore&scoringPeriodId=64"
raw.result <- GET(url = url)
library(httr)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mMatchup&view=mMatchupScore&scoringPeriodId=64"
raw.result <- GET(url = url)
raw.result
this.raw.content <- rawToChar(raw.result$content)
this.content <- fromJSON(this.raw.content)
this.content
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mMatchup&view=mMatchupScore&scoringPeriodId=64"
raw.result <- GET(url = url,
authenticate("user", "passwd"))
this.raw.content <- rawToChar(raw.result$content)
this.content <- fromJSON(this.raw.content)
this.content
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mMatchup&view=mMatchupScore&scoringPeriodId=64"
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95'))
this.raw.content <- rawToChar(raw.result$content)
this.content <- fromJSON(this.raw.content)
this.content
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?view=mMatchup&view=mMatchupScore&scoringPeriodId=64"
url
url
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95'))
raw.result
this.raw.content <- rawToChar(raw.result$content)
this.raw.content
getURL(url, userpwd="jyzhou2009@gmail.com:crazyboy95", httpauth = 1L)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?forTeamId=1&scoringPeriodId=65&view=mRoster"
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95'))
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95!'))
raw.result
this.raw.content <- rawToChar(raw.result$content)
this.raw.content
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?forTeamId=1&scoringPeriodId=65&view=mRoster"
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95!'))
raw.result
this.raw.content <- rawToChar(raw.result$content)
this.raw.content
this.content <- fromJSON(this.raw.content)
this.content
getURL(url, userpwd="key:secret", httpauth = 1L)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?forTeamId=1&scoringPeriodId=65&view=mRoster"
getURL(url, userpwd="jyzhou2009@gmail.com:crazyboy95!", httpauth = 1L)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?forTeamId=1&scoringPeriodId=65&view=mRoster"
getURL(url)
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95!'),
type = "basic")
raw.result
this.raw.content <- rawToChar(raw.result$content)
this.raw.content
raw.result <- GET(url = url, authenticate(user = 'jyzhou2009@gmail.com',
password = 'crazyboy95!', type = "basic"))
this.raw.content <- rawToChar(raw.result$content)
this.raw.content
library(RSelenium)
checkForServer()
driver <- rsDriver(browser=c("chrome"))
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?forTeamId=1&scoringPeriodId=65&view=mRoster"
driver <- rsDriver(browser=c("chrome"), )
remDr$closeall()
remDr <- driver[["client"]]
remDr$closeall()
driver <- rsDriver(browser=c("chrome"), )
driver <- rsDriver(browser=c("chrome"))
remDr <- driver[["client"]]
# remDr$open()
remDr$navigate(url)
remDr$closeall()
driver <- rsDriver(browser=c("chrome"))
driver <- rsDriver(browser=c("chrome"), port = 4444)
library(RSelenium)
url = "http://fantasy.espn.com/apis/v3/games/fba/seasons/2019/segments/0/leagues/8490389?forTeamId=1&scoringPeriodId=65&view=mRoster"
driver <- rsDriver(browser=c("chrome"))
remDr$server$stop()
remDr <- driver[["client"]]
driver <- rsDriver(browser=c("chrome"), port = 4567L)
driver
library(quantmod)
library(lattice)
library(timeSeries)
library(tseries)
library(rugarch)
library(data.table)
library(ggplot2)
library(glue)
library(parallel)
library(plotly)
funcGetStockPrice <- function(vec.symbols, start_date = Sys.Date() - 20, end_date = Sys.Date(), bln.all = FALSE,
verbose = FALSE){
dt.return.this <- rbindlist(lapply(1:length(vec.symbols), function(x){
tmp_stock <- vec.symbols[x]
if (verbose){
print(tmp_stock)
print(glue("Progress: {x/length(vec.symbols) * 100}%"))
}
dt.temp <- tryCatch({
if (bln.all){
getSymbols(Symbols = tmp_stock, auto.assign = FALSE)
} else{
getSymbols(Symbols = tmp_stock, from = start_date, to = end_date, auto.assign = FALSE)
}
},
error = function(cond){
return(data.table())
},
warning = function(cond){
return (data.table())
})
if (nrow(dt.temp)){
lst.dates <- index(dt.temp)
dt.temp <- data.table(dt.temp)
dt.temp$date <- lst.dates
dt.temp$symbol <- tmp_stock
colnames(dt.temp) <- c("open", "high", "low", "close", "volume", "adjusted_close", "dt", "symbol")
# Skip stock if volume is 0 but not if it's an index
if (any(dt.temp$volume == 0) & !grepl("%5E", tmp_stock)){
return (data.table())
}
dt.temp$returns <- returns(dt.temp$adjusted_close) + 1
dt.temp <- dt.temp[!is.na(returns)]
return (dt.temp)
} else{
return (data.table())
}
}))
return (dt.return.this)
}
funcCalcVolatility <- function(chr.symbol, start_date, end_date){
dt.stock  <- funcGetStockPrice(c(chr.symbol), as.Date("1960-01-01"), as.Date(end_date))
dt.stock <- dt.stock[dt >= start_date]
dt.stock$returns <- dt.stock$returns - 1
# Calculate 90 days annualized returns volatility
dt.stock$vol_90 <- c(rep(NA, 89), rollapply(data = dt.stock$returns,width=90,FUN=sd) * sqrt(252))
dt.stock <- dt.stock[!is.na(vol_90)]
# Predicted volatility is yesterday's volatility
dt.stock$pred_vol_90 <- c(NA, head(dt.stock$vol_90, -1))
dt.stock <- dt.stock[!is.na(pred_vol_90)]
return (dt.stock)
}
funcPlotVolatility <- function(dt.stock){
chr.symbol <- unique(dt.stock$symbol)
plt <- ggplot() + geom_line(data = dt.stock, aes(x = dt, y = vol_90, color = "Actual Volatility"), group = 1) +
geom_line(data = dt.stock, aes(x = dt, y = pred_vol_90, color = "One Day Lag Volatility"), group = 1) +
theme_bw(base_size = 20) + ggtitle(glue("{chr.symbol} 90 Volatility")) +
scale_colour_manual("",
breaks = c("Actual Volatility", "One Day Lag Volatility"),
values = c("black", "red"))
# Calculate MAE
flt.mae <- sum(abs(dt.stock$vol_90 - dt.stock$pred_vol_90))/nrow(dt.stock)
print(glue("Mean Absolute Error: {flt.mae * 100}%"))
ggplotly(plt)
}
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2005-01-01", end_date = Sys.Date())
dt.tlt <- funcCalcVolatility(chr.symbol = "TLT",start_date = "2005-01-01", end_date = Sys.Date())
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2005-01-01", end_date = Sys.Date())
dt.spy
library(quantmod)
library(lattice)
library(timeSeries)
library(tseries)
library(rugarch)
library(data.table)
library(ggplot2)
library(glue)
library(parallel)
library(plotly)
funcGetStockPrice <- function(vec.symbols, start_date = Sys.Date() - 20, end_date = Sys.Date(), bln.all = FALSE,
verbose = FALSE){
dt.return.this <- rbindlist(lapply(1:length(vec.symbols), function(x){
tmp_stock <- vec.symbols[x]
if (verbose){
print(tmp_stock)
print(glue("Progress: {x/length(vec.symbols) * 100}%"))
}
dt.temp <- tryCatch({
if (bln.all){
getSymbols(Symbols = tmp_stock, auto.assign = FALSE)
} else{
getSymbols(Symbols = tmp_stock, from = start_date, to = end_date, auto.assign = FALSE)
}
},
error = function(cond){
return(data.table())
},
warning = function(cond){
return (data.table())
})
if (nrow(dt.temp)){
lst.dates <- index(dt.temp)
dt.temp <- data.table(dt.temp)
dt.temp$date <- lst.dates
dt.temp$symbol <- tmp_stock
colnames(dt.temp) <- c("open", "high", "low", "close", "volume", "adjusted_close", "dt", "symbol")
# Skip stock if volume is 0 but not if it's an index
if (any(dt.temp$volume == 0) & !grepl("%5E", tmp_stock)){
return (data.table())
}
dt.temp$returns <- returns(dt.temp$adjusted_close) + 1
dt.temp <- dt.temp[!is.na(returns)]
return (dt.temp)
} else{
return (data.table())
}
}))
return (dt.return.this)
}
funcCalcVolatility <- function(chr.symbol, start_date, end_date, lookback = 90){
dt.stock  <- funcGetStockPrice(c(chr.symbol), as.Date("1960-01-01"), as.Date(end_date))
dt.stock <- dt.stock[dt >= start_date]
dt.stock$returns <- dt.stock$returns - 1
# Calculate 90 days annualized returns volatility
dt.stock$vol_90 <- c(rep(NA, lookback-1), rollapply(data = dt.stock$returns,width=lookback,FUN=sd) * sqrt(252))
dt.stock <- dt.stock[!is.na(vol_90)]
# Predicted volatility is yesterday's volatility
dt.stock$pred_vol_90 <- c(NA, head(dt.stock$vol_90, -1))
dt.stock <- dt.stock[!is.na(pred_vol_90)]
return (dt.stock)
}
funcPlotVolatility <- function(dt.stock){
chr.symbol <- unique(dt.stock$symbol)
plt <- ggplot() + geom_line(data = dt.stock, aes(x = dt, y = vol_90, color = "Actual Volatility"), group = 1) +
geom_line(data = dt.stock, aes(x = dt, y = pred_vol_90, color = "One Day Lag Volatility"), group = 1) +
theme_bw(base_size = 20) + ggtitle(glue("{chr.symbol} 90 Volatility")) +
scale_colour_manual("",
breaks = c("Actual Volatility", "One Day Lag Volatility"),
values = c("black", "red"))
# Calculate MAE
flt.mae <- sum(abs(dt.stock$vol_90 - dt.stock$pred_vol_90))/nrow(dt.stock)
print(glue("Mean Absolute Error: {flt.mae * 100}%"))
ggplotly(plt)
}
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2005-01-01", end_date = Sys.Date(), lookback = 10)
dt.tlt <- funcCalcVolatility(chr.symbol = "TLT",start_date = "2005-01-01", end_date = Sys.Date(), lookback = 10)
funcPlotVolatility(dt.spy)
funcPlotVolatility(dt.tlt)
library(data.table)
library(ggplot2)
library(plotly)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
dir_path <- paste0(parent_dir, "/results_combinations")
result_list <- list.files(dir_path)
dt.results <- rbindlist(lapply(result_list, function(x) fread(paste0(dir_path, "/", x))))
dt.results[,V1 := NULL]
dt.results[,score_delta := as.numeric(score_delta)]
dt.results[,sharpe_ratio := as.numeric(sharpe_ratio)]
dt.results <- dt.results[status != "ERROR"]
dt.results[,strategy := paste(head(unlist(strsplit(alpha_id, "\\_")), -1), collapse = "_"), by = 1:nrow(dt.results)]
my_plot <- ggplot(dt.results, aes(x = sharpe_ratio, score_delta, text = paste0("alpha_id: ", alpha_id,
"\nturn_over: ", turn_over,
"\nfitness: ", fitness,
"\nreturns: ", returns),
color = status)) + geom_point(size = 1.5) +
geom_hline(yintercept = 0, size=1) + geom_vline(xintercept = 0, size=1)
ggplotly(my_plot)
dt.results
